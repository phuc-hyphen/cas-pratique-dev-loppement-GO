package main

import (
	"fmt"
	"log"
	"net/http"

	gosocketio "github.com/graarh/golang-socketio"
	"github.com/graarh/golang-socketio/transport"

	"github.com/gorilla/handlers"

	"github.com/gorilla/mux"
)

var router *mux.router

func main()  {
	
	LoadSocket()
	CreateRouter()
	InitializeRoutes()
	StartServer()
}


// Create a Router and initialize routes

func CreateRouter() {
	router = mux.NewRouter()
}
func InitializeRoutes() {
	router.Methods("OPTIONS").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "")
			w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT,DELETE")
			w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, Access-Control-Request-Headers, Access-Control-Request-Method, Connection, Host, Origin, User-Agent, Referer, Cache-Control, X-header")
	})
	router.Handle("/socket.io/", Server)
}

// initialize routes server 
var (
	Server *gosocketio.Server
)
func init() {
	Server = gosocketio.NewServer(transport.GetDefaultWebsocketTransport())
	fmt.Println("Socket Initialize...")
}
func StartServer() {
	fmt.Println("Server Started at http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", handlers.CORS(handlers.AllowedHeaders([]string{"X-Requested-With", "Access-Control-Allow-Origin", "Content-Type", "Authorization"}), handlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS"}), handlers.AllowedOrigins([]string{"*"}))(router)))
}
//CORS: Cross-origin resource sharing

type Message struct {
	Text string `json:"message"`
}

//set up socket.io 

func LoadSocket() {
	// socket connection
	Server.On(gosocketio.OnConnection, func(c *gosocketio.Channel) {
			fmt.Println("Connected", c.Id())
			c.Join("Room")
	})

	// socket disconnection
	Server.On(gosocketio.OnDisconnection, func(c *gosocketio.Channel) {
			fmt.Println("Disconnected", c.Id())

			// handles when someone closes the tab
			c.Leave("Room")
	})

	// chat socket
	Server.On("/chat", func(c *gosocketio.Channel, message Message) string {
			fmt.Println(message.Text)
			c.BroadcastTo("Room", "/message", message.Text)
			return "message sent successfully."
	})
}


func Server3File(w http.ResponseWriter, r *http.Request) {

	switch r.Method {

	case "GET":

		path := r.URL.Path

		fmt.Println(path)

		if path == "/" {

			path = "./welcome-template.html"
		} else {
			path = "/" + path
		}
		http.ServeFile(w, r, path)
	case "POST":

		r.ParseMultipartForm(0)

		message := r.FormValue("message")

		fmt.Println("--------------------------------------------------------------")
		fmt.Println("Message from Client ", message)
		// response to client request

		fmt.Fprintf(w, " Sever: %s \n", message+"|"+time.Now().Format(time.RFC3339))

	default:
		fmt.Fprint(w, "Request type other than GET or POST not supported")
	}

}
// // check the requirement of the pseudo name 
  //   if (pseudo.length < 20) {
  //   if(infor.includes(pseudo)==false)
  //       {
  //           infor.push(pseudo)
  //           mes.innerHTML=pseudo
  //           console.log(pseudo, " pseudo name can be used")
  //           console.log(" entry in successful, "+ pseudo + " enter the room ")
  //           console.log(infor)
  //           return
  //       }
  //   mes.innerHTML = " Pseudo name have been used !! Please choose another one"
  //   return
  // }
  // mes.innerHTML = "Pseudo name is too long (limited at 20 characters)"